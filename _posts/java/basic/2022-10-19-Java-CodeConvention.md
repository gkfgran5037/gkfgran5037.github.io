---
title:  "JAVA Code Convention"
categories:
  - dataStructure
---

---
## 변수
<br/>

### 선언 위치
- 상수, 클래스 변수, 인스턴스 변수, 생성자 순
- 상수와 인스턴스 변수의 구분을 위해서 공백 라인 필요

### 상수
- static final
- 변수명 대문자
- final : 한 번 초기화된 후 변경 불가
- static : 메모리에 로드되면 클래스(인스턴스)가 공유할 수 있음

### final 사용해 값 변경 막기
- 값의 변경 방지
- 로컬 변수에서는 지양

### 객체의 상태 접근을 제한
객체 인스턴스 변수의 접근 제어자는 private으로 구현

### 인스턴스 변수의 수 최소화
- 인스턴스 변수의 수 최소화
- 중복 제거


<br/><br/><br/>




--
## 메소드
<br/>

### setter 메소드 자제
- 인스턴스를 초기화한 후에 값을 변경할 수 있는 setter 메소드를 생성하지 않음
- 생성자를 사용해 초기화 지향

### 상태 데이터를 get하지 말고 메시지를 보내라
- 객체의 데이터를 꺼내 로직을 구현하면 중복 코드 발생 우려
- 객체의 메시지를 보내 상태 데이터를 가지는 객체 사용
- 현재 객체의 상태를 보기 위한 로그 메시지 성격이 강하다면 toString()을 통해 구현
- View에서 사용할 데이터라면 getter 메소드를 통해 데이터를 전달
  - DTO(Data Transfer Object)의 경우 getter, setter 허용
  - 도메인 Layer -> View Layer / View Layer -> 도메인 Layer로 데이터 전달 시 = DTO

#### static
상태를 가지지 않는 클래스라면 정적 메서드만을 갖는 유틸리티 클래스로 만들어보는 것도 좋음 (리뷰어)

<br/><br/><br/>



--
## 생성자
<br/>

### 불필요한 객체 생성 제한
정적 메서드만을 포함하는 클래스라면, private 생성자를 추가하여 불필요한 인스턴스화를 방지

<br/><br/><br/>





--
## 로직
<br/>

### 비지니스 로직과 UI 로직의 분리
- 비지니스 로직과 UI 로직을 한 클래스가 담당하지 않도록 함
- 단일 책임의 원칙에도 위배됨

### Collection 활용 로직 처리
- API, Stream 등 활용

### MVC 패턴 (Model View Controller)
- MVC 패턴 구조를 유지하면서 구현
- 큰 틀에서 분리 가능

<br/><br/><br/>




--
## 테스트
<br/>

### 경계 값을 기준으로 테스트

### Test Fixture 생성
- Fixture 란
  - 테스트를 실행하기 위해 필요한 것
  - 테스트를 실행하기 위해 준비해야 할 것
- 테스트의 인스턴스 변수는 각 Test Case에서 공통으로 필요한 Fixture만 위치, 나머지는 각 Test Case에 로컬 변수호 구현
- @BeforEach는 각 Test Case에서 중복으로 사용하는 Fixture만 초기화해야 함

### 특정 상태를 만들기 위한 반복 코드 지양
- 생성자를 추가하여 반복 코드 줄여보기




### private 메소드 테스트하고 싶다면 설계를 의심하자
- 클래스가 너무 많은 기능을 담당하고 있는지 의심하기
- 클래스 분리

<br/><br/><br/>




--
## 기타
<br/>

### 공백
문맥 분리하는 부분에 사용

## space
고려 필요
- ex) i = 2

### 네이밍(이름 짓기)
- 축약 금지
- 한정어를 붙여야 한다면 이름 끝에 붙임 
  - ex) appleTotal

<br/><br/><br/>